# JAVA虚拟机

## 一、内存与回收机制

### 1、JVM及其体系结构

![image-20200917152216078](img\image-20200917152216078.png)

相关的概念： 

   *    OOM :  内存的溢出问题
   *    GC : 垃圾回收机制

结构层次：  高级语言---->  汇编语言 -------> 及其指令------> CPU

对比于c++,java能动态分配内存，以及具备垃圾回收机制，但是在c++中，我们都是由程序员来进行分配内存和回收垃圾。

#### 1、跨平台

java结尾的源文件，生成字节码文件（.class），然后在不同的JVM上去运行。

![image-20200922130459437](img\image-20200922130459437.png)

在java虚拟机平台上可以运行非java语言编写的程序，值得注意的是：java虚拟机并不关心在其内部运行的程序到底是何种语言编写的，它只关心“字节码”文件，只要其他编程语言的编译结果满足并包含java虚拟机的内部指令集，符号，及其他的辅助信息，他就是一个有效的字节码文件，就能被识别并装载运行。

#### 2、虚拟机

虚拟机可以分为系统虚拟机和程序虚拟机

* 系统虚拟机也就是Visual Box, VMware,这类就属于系统虚拟机，是在操作系统之上的软件层面对物理计算机的仿真，
* 程序虚拟机的典型带边就是java虚拟机，专门为执行单个计算机程序而设计的，**在java虚拟机中执行的指令我们成为java字节码指令**（javac编译之后形成的）。

#### 3、整体结构

![image-20200927145326480](img\image-20200927145326480.png)

> 个小部分的简单说明与介绍： 代码文件（.java） 通过前端编译器（javac）产生字节码文件（.class）,然后通过我们的类加载机制，加载到运行时数据区（内存空间），运行时数据区主要包含（方法区【method Area】，堆【heap】, java栈【java stack】, 本地方法栈【Native Method Stack】,程序技术器【Program Counter Register】) 值得注意的是，堆和方法区是多线程共享的。然后通过执行引擎（Execution Engine）翻译成机器指令供操作系统执行。

#### 4、执行流程

![image-20200927150640015](img\image-20200927150640015.png)



#### 5、相关指令

对于JVM来讲，是基于栈进行的，对于类似安卓系统来讲，是基于寄存器进行的。

> 这里顺便解释下为什么说java是解释性的语言，通过前面的学习，我们知道.java文件即使是被编译成.class，但是还是不能够被机器执行的，是需要通过jvm中的执行引擎通过逐一的解释，执行，才能被执行，因此，才说java是解释性的语言，所以，这里就有了前端编译器和后端解释器的概念。

栈：跨平台性，指令集小，指令多，执行性能比寄存器差。

这里先了解个概念：

关于反编译：也就是将class文件反编译成我们能够看的懂的源文件，有什么jad呀以及其他的什么之类的，以及我们的命令行参数javap命令，在相关的.class目录下使用命令 javap - v  program.class，就会生成相应的源文件码来使用。

#### 6、JVM的生命周期

**虚拟机的启动**：

* java虚拟机的启动时通过引导类加载器（bootstrap loader）创建一个初始类（initial class） 来完成的，这个类是由虚拟机的具体实现指定。

**虚拟机的执行：**

* 一个运行的java虚拟机有若干个清晰的任务：执行java程序。
* 程序开始执行时他才运行，程序结束时他就停止。
* 执行一个所谓的java程序时候，真真正正在执行的是一个java虚拟机的进程。

**虚拟机的退出：**

* 程序正常执行结束
* 程序在执行的过程中遇到异常或错误而异常终止
* 由于操作系统出现错误而导致java虚拟机进程终止。
* 某线程调动Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作。



堆内存中存储的是new 出来的东西

方法区里面存储的是字节码

方法栈中存储的是方法，在被调用的时候使用，方法中的字面量存储在方法栈中，如果是引用数据类型，存储的是堆中的地址。

#### 7、常见的JVM版本

* Sun Classic VM: 最早的java虚拟机，执行引擎分由解释器（逐行进行解释）和JIT（just-in-time compilation）及时编译器（快速编译形成热点代码，并将机器指令存储在内存缓存中）组成，但是不能交替工作，只能单独工作，JIT是通过外挂的形式进行工作，不能识别数据是引用的地址还是基本数据类型。
* Exact VM :编译器能够与JIT混合工作，提升其效率，能够分别数据与引用，还具有热点探测的功能。
* BEA   JRockit : 牺牲了解释器，用JNT的模式 进行工作，常用在服务器端，是运行最快的虚拟机。
* Hotspot : 也就是我们最常见的。
* J9: 这个是IBM公司开发的，一般来说主要是公司内部产品的底层工具，性能较好，未开源。
* 以及其他的一些。

### 二、类加载子系统（class loader subSystem）

![image-20200930091742907](img\image-20200930091742907.png)

![image-20200930092318302](img\image-20200930092318302.png)

