# JAVA虚拟机

## 一、内存与回收机制

### 1）、JVM及其体系结构

![image-20200917152216078](img\image-20200917152216078.png)

相关的概念： 

   *    OOM :  内存的溢出问题
   *    GC : 垃圾回收机制

结构层次：  高级语言---->  汇编语言 -------> 及其指令------> CPU

对比于c++,java能动态分配内存，以及具备垃圾回收机制，但是在c++中，我们都是由程序员来进行分配内存和回收垃圾。

#### 1、跨平台

java结尾的源文件，生成字节码文件（.class），然后在不同的JVM上去运行。

![image-20200922130459437](img\image-20200922130459437.png)

在java虚拟机平台上可以运行非java语言编写的程序，值得注意的是：java虚拟机并不关心在其内部运行的程序到底是何种语言编写的，它只关心“字节码”文件，只要其他编程语言的编译结果满足并包含java虚拟机的内部指令集，符号，及其他的辅助信息，他就是一个有效的字节码文件，就能被识别并装载运行。

#### 2、虚拟机

虚拟机可以分为系统虚拟机和程序虚拟机

* 系统虚拟机也就是Visual Box, VMware,这类就属于系统虚拟机，是在操作系统之上的软件层面对物理计算机的仿真，
* 程序虚拟机的典型带边就是java虚拟机，专门为执行单个计算机程序而设计的，**在java虚拟机中执行的指令我们成为java字节码指令**（javac编译之后形成的）。

#### 3、整体结构

![image-20200927145326480](img\image-20200927145326480.png)

> 个小部分的简单说明与介绍： 代码文件（.java） 通过前端编译器（javac）产生字节码文件（.class）,然后通过我们的类加载机制，加载到运行时数据区（内存空间），运行时数据区主要包含（方法区【method Area】，堆【heap】, java栈【java stack】, 本地方法栈【Native Method Stack】,程序技术器【Program Counter Register】) 值得注意的是，堆和方法区是多线程共享的。然后通过执行引擎（Execution Engine）翻译成机器指令供操作系统执行。

#### 4、执行流程

![image-20200927150640015](img\image-20200927150640015.png)



#### 5、相关指令

对于JVM来讲，是基于栈进行的，对于类似安卓系统来讲，是基于寄存器进行的。

> 这里顺便解释下为什么说java是解释性的语言，通过前面的学习，我们知道.java文件即使是被编译成.class，但是还是不能够被机器执行的，是需要通过jvm中的执行引擎通过逐一的解释，执行，才能被执行，因此，才说java是解释性的语言，所以，这里就有了前端编译器和后端解释器的概念。

栈：跨平台性，指令集小，指令多，执行性能比寄存器差。

这里先了解个概念：

关于反编译：也就是将class文件反编译成我们能够看的懂的源文件，有什么jad呀以及其他的什么之类的，以及我们的命令行参数javap命令，在相关的.class目录下使用命令 javap - v  program.class，就会生成相应的源文件码来使用。

#### 6、JVM的生命周期

**虚拟机的启动**：

* java虚拟机的启动时通过引导类加载器（bootstrap loader）创建一个初始类（initial class） 来完成的，这个类是由虚拟机的具体实现指定。

**虚拟机的执行：**

* 一个运行的java虚拟机有若干个清晰的任务：执行java程序。
* 程序开始执行时他才运行，程序结束时他就停止。
* 执行一个所谓的java程序时候，真真正正在执行的是一个java虚拟机的进程。

**虚拟机的退出：**

* 程序正常执行结束
* 程序在执行的过程中遇到异常或错误而异常终止
* 由于操作系统出现错误而导致java虚拟机进程终止。
* 某线程调动Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作。



堆内存中存储的是new 出来的东西

方法区里面存储的是字节码

方法栈中存储的是方法，在被调用的时候使用，方法中的字面量存储在方法栈中，如果是引用数据类型，存储的是堆中的地址。

#### 7、常见的JVM版本

* Sun Classic VM: 最早的java虚拟机，执行引擎分由解释器（逐行进行解释）和JIT（just-in-time compilation）及时编译器（快速编译形成热点代码，并将机器指令存储在内存缓存中）组成，但是不能交替工作，只能单独工作，JIT是通过外挂的形式进行工作，不能识别数据是引用的地址还是基本数据类型。
* Exact VM :编译器能够与JIT混合工作，提升其效率，能够分别数据与引用，还具有热点探测的功能。
* BEA   JRockit : 牺牲了解释器，用JNT的模式 进行工作，常用在服务器端，是运行最快的虚拟机。
* Hotspot : 也就是我们最常见的。
* J9: 这个是IBM公司开发的，一般来说主要是公司内部产品的底层工具，性能较好，未开源。
* 以及其他的一些。

### 2）、类加载子系统（class loader subSystem）

![image-20200930091742907](img\image-20200930091742907.png)

![image-20200930092318302](img\image-20200930092318302.png)

加载的过程：

![image-20201009091651571](img\image-20201009091651571.png)

#### 1、加载阶段

* 通过一个类的权限定名获取此类的二进制字节流
* 将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

![image-20201009092936825](img\image-20201009092936825.png)

#### 2、链接阶段

> 链接包含 验证（Verify），准备(Prepare)，解析(Resolve)

![image-20201009094739118](img\image-20201009094739118.png)

> 1、所谓验证，就是要在二进制流加载的过程中检验其字节码文件的合法性，class文件，也就是JVM所识别的文件，都会有一个 CA FE BA BE 的关键字节码。2、准备中的赋予初值要注意，如有：static int i = 1;是先赋值为0，在初始化阶段再赋值为1的。

#### 3、初始化阶段

![image-20201009095621706](img\image-20201009095621706.png)

对于执行<clinit>()方法的过程，我们用个例子来说明：

```java
public class MyTest {

    public static int num = 1;
    static {
        num = 5;
        number = 20;
        //System.out.println(number);   //非法向前引用
    }

    public static int number = 10;


    public static void main(String[] args) {
        System.out.println(MyTest.num);   //5
        System.out.println(MyTest.number);  //10
    }
}
```

> 在链接的准备阶段，对num=0;   number=0进行赋初值，然后到初始化阶段，执行<clinit>()进行赋值操作，num先赋值为1，然后赋值为5，number先赋值为20，然后赋值为10，注意的是，虽然可以进行赋值的左操作，但是不能进行右操作。同时，如果该类中没有静态变量，就不会执行<clinit>()函数。

关于多线程，指的是加载类的操作仅仅只会执行一遍，而不会执行多次。下面举个例子：

```java
/*
 *@author by java开发-曾
 *2020/9/26 16:11
 *文件说明：
 */
public class MyTest implements Runnable{

    public static void main(String[] args) {
       Runnable r = new Runnable() {
           @Override
           public void run() {
               System.out.println(Thread.currentThread().getName()+"开始");
               //类在线程中被加载
               Run run = new Run();
               System.out.println(Thread.currentThread().getName()+"结束");
           }
       };

       Thread th1 = new Thread(r,"线程1");
        Thread th2 = new Thread(r,"线程2");

        th1.start();
        th2.start();

    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"开始");
        //类在线程中被加载
        Run run = new Run();
        System.out.println(Thread.currentThread().getName()+"结束");
    }
}

class Run{

    static {
        if(true){
            System.out.println("该类被加载"+Thread.currentThread().getName());
            while (true){

            }
        }

    }
}

//运行结果
线程1开始
线程2开始
该类被加载线程1
```

#### 4、关于加载器的简介

> 类在被加载的过程，我们对加载器进行分类，分为两种 ：bootStrapClassloader(引导类加载器) 和 自定义加载器，
>
> 对于引导类加载器，他是使用c++/c语言编写的，对于自定义加载器，是直接或者间接的继承了Classloader,是在java中可以具体实现的。对于这几类加载器，是没有具体的继承等关系的，但是有上下级的关系。具体在下面的代码中可以看出：

```java
//获取系统类加载器
ClassLoader appClassloader = ClassLoader.getSystemClassLoader();
System.out.println(appClassloader);  //  sun.misc.Launcher$AppClassLoader@18b4aac2

//获取上层的扩展类加载器
ClassLoader exClassLoader = appClassloader.getParent();
System.out.println(exClassLoader);  //  sun.misc.Launcher$ExtClassLoader@1b6d3586

//获取上层的引导类加载器
ClassLoader bootClassloader = exClassLoader.getParent();
System.out.println(bootClassloader); //null: 因为引导类加载器是用c++/c 进行编写的
                                     //已经超出了java的范畴，是获取不到该对象的。

//看下我们具体使用的类是用哪些加载器来加载的

//我们的自定义类：MyTest  可以看出是用的系统类加载器
ClassLoader classLoader = MyTest.class.getClassLoader();
System.out.println(classLoader);   //sun.misc.Launcher$AppClassLoader@18b4aac2

//在看看我们的String  使用的是引导类   值得注意的是，我们java中的核心类库都是由引导类加载器进行加载的
ClassLoader classLoader1 = String.class.getClassLoader();
System.out.println(classLoader1);  //null
```

具体的介绍：

![image-20201009144559325](img\image-20201009144559325.png)

![image-20201009145113009](img\image-20201009145113009.png)

![image-20201009145543640](img\image-20201009145543640.png)

获取加载器加载的路径：

```java
//获取引导类加载器的类文件的目录
  URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
  for (URL urL : urLs) {
      System.out.println(urL);
  }

  //同样，我们也可以来查看扩展类加载器加载的目录结构是什么
  String property = System.getProperty("java.ext.dirs");
  for (String url: property.split(";")) {
      System.out.println(url);
  }
```

![image-20201009151508212](img\image-20201009151508212.png)

![image-20201009152029560](img\image-20201009152029560.png)

#### 5、双亲委派机制

> java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成的class对象中，而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，他是一种任务委派模式。

![image-20201009154453028](img\image-20201009154453028.png)

优势：

* 避免类被重复加载
* 起保护作用，比如自定义类的包名为java.lang ,但是引导类加载器具有权限，因此是不能被加载的。

#### 6、沙箱安全机制

一、概念

保证对java核心源代码的保护，就是沙箱安全机制。
就是一种保护机制，保护源代码，保护JVM不受恶意代码的破坏。

二、示例

自定义的String类（java.lang.String），但是加载自定义类的时候回率先使用引导类加载器加载，而引导类加载器在加载的时候先加载jdk自带的文件(rt.jar包中的java\lang\String.class)，不会加载自定义的String类，这样就保护了java的源码，不会受到污染。

#### 7、其他

1）在JVM中表示两个class对象是否为同一个类存在的必要条件：

* 类的完整类名必须一致，包括类名
* 加载这个类的Classloader(指ClassLoader实例对象)必须相同

> 换句话说，在JVM中，即时这两个类对象(class对象)来源于同一个class文件，被同一个虚拟机加载，但是加载器不同，两个类对象也是不相等的。

![image-20201009201637316](img\image-20201009201637316.png)

类的主动使用与被动使用

![image-20201009202132269](img\image-20201009202132269.png)

### 3）、运行时数据区概述及线程

#### 1、简介

![image-20201009203817985](img\image-20201009203817985.png)

![image-20201009204406992](img\image-20201009204406992.png)

#### 2、程序计数器

> program Counter Register  :程序计数寄存器。主要存储指令相关的现场信息，cpu只有把数据装载到寄存器中才能运行。

![image-20201012213024976](img\image-20201012213024976.png)

![image-20201012213237301](img\image-20201012213237301.png)

![image-20201012213540995](img\image-20201012213540995.png)

> 也就是说，pc是不存在垃圾回收的，也是不存在内存溢出的，但是本地方法栈和虚拟机栈是可能出现内存溢出的（当栈满的时候）

PC寄存器的一个大致流程：

![image-20201012214754418](img\image-20201012214754418.png)

关于PC寄存器的两个问题：

![image-20201012215204130](img\image-20201012215204130.png)

#### 3、虚拟机栈

1）虚拟机栈出现的背景：

![image-20201012220527061](img\image-20201012220527061.png)

> 栈是运行时的单位，而堆是存储的单位

![image-20201012221407092](img\image-20201012221407092.png)

> 注意的是：这里说明的局部变量，要与成员变量（属性）有所区分，局部变量又分为8种基本数据类型和引用类型变量（类，数组，接口） 所以如果是引用类型，就是引用地址。

方法的执行就是入栈的操作，执行结束就是出栈操作：

![image-20201012221929302](img\image-20201012221929302.png)

> 对于栈来讲，并不存在垃圾回收的问题，但是存在OOM(栈溢出),

![image-20201013101530959](img\image-20201013101530959.png)

![image-20201013101818156](img\image-20201013101818156.png)

> 在栈中不断去自己调用自己，也就会重复出现局部变量表，如果死循环，就会造成栈溢出，所以诸如递归等都要向已知的方向走。

如何查看或者设置栈的内存大小呢？

![image-20201013103432560](img\image-20201013103432560.png)

> 因此，对于栈空间的调优，就可以使用 -Xss来设置栈空间的大小的问题。

2）栈的存储单位

> 每个线程都有自己的栈结构，在栈中的基本单位是栈帧（stack Frame）的格式存在，每个方法都对应着一个栈帧。
>
> 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

这里要注意的是，java方法中有两种返回函数的形式，

* 一种是正常的函数返回，使用return指令。
* 另一种是抛出异常，不管使用哪种方式，栈帧都会被弹出

> 这里要强调的是，如果方法的返回值是void,也可以在方法结束后使用 return ;但是没有返回值，因为反编译的源码上每个方法都是有一个return操作的，另外，对抛出异常，会向上层方法进行异常的抛出。

3）栈帧的内部结构

![image-20201013142901926](img\image-20201013142901926.png)

> 局部变量表： 局部变量表被称为局部变量数组，或本地变量表
>
> 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括基本数据类型，对象引用，以及returnAddress类型
>
> 定义在线程内部，不存在数据安全的问题
>
> 局部变量表所需的容量大小是在编译期确定的，并保存在方法Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部标量表的大小的。

> 这里需要注意的是，当一个线程的栈的容量固定后，如果我们每个栈帧的局部标量表的容量很大的话，就会减少栈帧的数目，方法的嵌套就会减少。

关于Slot的理解：

![image-20201013151739078](img\image-20201013151739078.png)

> 引用数据类型也是占用的32位，1个Slot。

![image-20201013152643654](img\image-20201013152643654.png)

> 对于静态方法不能用this，一方面来讲，this表示当前对象，不能放在静态方法，另一种层面来讲，虚拟机栈帧中的局部变量表中是没有声明这样的一个变量的。

Slot的重复利用的问题

> 栈帧中的局部变量表的槽位是可以进行重复利用的，如果一个局部标量过了作用域，那么在其作用域之后申明的新的局部变量就很可能会重复过期的局部标量的槽位，从而节约资源。

```java
public static void main(String[] args) throws FileNotFoundException {
   int a = 1;
    {
        int b = 3;
        a = b;
    }
    //b的作用域结束了后，后面定义的变量就会复用b的局部变量表的空间
    int c = 4;
    System.out.println(a);

}
```

![image-20201013154405329](img\image-20201013154405329.png)

> 针对局部变量的一个说明：局部变量必须进行显示赋值，因为在表中药存储值，并没有默认赋值的操作，对于静态变量，前面说了会在类的加载过程中进行赋值的操作，对于实例变量来说，会在堆空间中进行初始化赋值。

> 补充说明：在栈帧中，与性能调优关系最为密切的部分就是局部变量表，在执行方法时，虚拟机使用局部变量表完成方法的传递。
>
> 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

#### 4、操作数栈

> 操作数栈（Operand stack） 使用数组来实现的，也可以叫表达式栈，用来存储临时值。

![image-20201013163616157](img\image-20201013163616157.png)

> 上面这种字节码基于操作数栈的执行过程中，可以说java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈

![image-20201013164654758](img\image-20201013164654758.png)

代码进行测试：

```java
public void tesyt(){
    
    /*
    0 aload_0 :加载this
    1 invokevirtual #4 <MyTest.Sum>:执行栈中的函数
    这个函数执行后，会将返回值存入到栈的栈顶中
    4 istore_1  :取出栈顶的值，将值保存到局部变量表中
    5 return
     */
    int i = Sum();
}


public int Sum(){

    //对应的解析字节码
    /*
    bipush 10 :将byte类型向int类型转换 push到操作数栈中
    istore_1 : 将栈顶的值存储到局部变量索引为1的位置处
    并进行出栈操作
     */
    byte i = 10;

    /*
    bipush 20 :将byte类型向int类型转换 push到操作数栈中
    istore_2 : 将栈顶的值存储到局部变量索引为2的位置处
    并进行出栈操作
     */
    int j = 20;

    /*
      iload_1: 将局部变量表中1位置的数压到栈中：10
      iload_2：将局部变量表中2位置的数压到栈中：20
      iadd  :进行出栈相加的操作，并将结果进行入栈
      istore_3：出栈，存储到局部变量3
     */
    int k = i+j;

    /*
     iload_3: 加载
     并将值进行返回
     */
    return k;

}
```

#### 6、栈顶缓存技术

> 栈顶缓存技术（Top-of-stack cashing）

![image-20201013182053457](img\image-20201013182053457.png)

> 也就是说，更多的入栈出栈操作由于没有地址，因此会形成更多的指令。指令更多，访问的速度就变得慢了。

#### 7、动态链接

> 指向运行时常量次的方法引用，也就是说我们把类加载到运行时数据区时，类中的方法和变量保存到运行时常量池中。在使用这些的时候就需要动态链接去引用。

![image-20201013184448863](img\image-20201013184448863.png)

#### 8、方法的调用

![image-20201014130550851](img\image-20201014130550851.png)

> 注意的是：这里对静态链接也称为非虚方法，动态链接也称为虚方法，，非虚方法包括：父类的构造方法，final，static，private修饰的方法。也可以称为静态绑定和动态绑定，或者前期绑定与后期绑定。

![image-20201014132825802](img\image-20201014132825802.png)

> 对于invokedynamic指令，这个是jdk1.7之后才出现的，是java为实现动态类型语言的支持做的一种改进。但是找各种指令，到1.8的时候才有了最直接的表现，如lambda（函数式编程），注意的是，像这种修改，实际上是对jvm规范的修改，并没有对语言进行改写。

动态语言与静态语言：

上面我们说到了静态语言和动态语言，对于静态语言来说，就是在编译期间就能确定判断变量自身的类型信息，而动态语言就是判断值的类型信息，所以说，Java就是静态语言，而像javascript  python 就是动态语言，比如js: 定义变量是var/let 并不知道是什么类型，在运行时，系统才知道。而python就做的更加的彻底。

#### 9、方法重写的本质

* 首先找到栈顶的第一个元素的对象的实际类型，（这里说明下声明类型（前面的定义）和实际类型（后面的new））为c。
* 如果类型c中找到与常量中描述相符合的方法，解酒进行访问权限验证，并进行访问，如果结束，不通过，就返回异常，
* 否则，就暗战继承关系从下往上依次对C的各个父类进行搜索和验证。
* 如果始终没有找到，就返回异常。

由于这种方法使用每次都要去搜索和验证，降低了性能，因此，在类的方法区中会建立一个虚方法表，直接将类中的虚方法和非虚方法存起来，如果是继承的没有重写的方法，就保存该方法的索引位置，如果重写了，就访问其直接引用地址。

#### 10、方法返回地址

就是指在return的执行过程中，会保存着嵌入这个方法的下一条指令，因为方法结束后要出栈，并且要执行外层的方法，因此，pc计数器要知道指令应该怎么去执行。

#### 11、栈中的附加信息

在很多的网上贴中，会将方法返回地址，动态链接，附加信息，统称的叫做帧数据区。对于部分的jvm来讲，可能是没有附加信息的，这个知道就行了。

#### 12、常见的栈面试题

1）举例栈溢出的情况

> 前面讲过，栈的深度如果是固定的，那么当栈帧比较多的时候，再向栈中放栈帧就会出现栈溢出（stackOverFlow） 如果是动态分配，当内存不足够进行分配时，也就会出现内存溢出。

2）调整栈的大小，就能保证不出现溢出吗？

> 不能，如果是循环迭代，并且是无限循环的，就不能保证栈的溢出了。

3）分配的栈的内存越大越好吗？

> 不是，对于他自身来讲，肯定是越大越好，但是对于其他的如堆，方法区来讲，就不是了。

4）垃圾回收机制是否会涉及到虚拟机栈？

> 不会涉及，他只有入栈和出栈的操作，只会有内存溢出的情况。

5）方法中定义的局部变量是否线程安全？

> 对于局部变量，首先是内部定义，内部销毁，才是线程安全的，否则都不是，如形式参数中的，如通过return进行返回了的。

#### 13、本地方法栈的理解

> 首先要明确的是，本地方法接口这个概念，就是比如在Object类中，在Thread类中出现的用native修饰的方法接口，他的实际上是用c/c++进行编写的，通过这个接口会去调用本地的方法类库，那这个有什么用呢？比如说访问硬件上面的东西，或者硬件中c已经实现的东西。

对于本地方法栈，具体来讲是和虚拟机栈的区别不是很大，数据结构来讲，都是用栈来实现的。

#### 14、堆的相关

> 堆也是属于运行时数据区中的一块，堆在启动时被创立，大小是确定的，是最大的内存空间，当然，堆内存是可以通过参数进行调节的。堆在物理存储上是不连续的，但是在逻辑上是连续的，这种形式是通过物理与逻辑建立映射表来实现的。

另外一个点是：TLAB: 为每一个线程分配一块堆内存空间，是独享的。（私有缓冲区）

所有的线程共享堆空间，因此，堆是属于进程级别的，在java中，对象被创建在堆中，（逃逸现象出现时，可能创建在栈中），当堆中的内存满了后，就会被GC所回收。

关于堆的内存结构的说明：（分代收集理论设计）

在jdk7及以前： 新生代（年轻代）+老年代（养老区）+永久代(Prem)（这个概念虽然属于堆，但是不完全归堆管）

在jdk8及以后：新生代（年轻代）+老年代（养老区）+元空间(meta space)（这个概念虽然属于堆，但是不完全归堆管，这个是在方法区中的落地实现的）

而新生代又分为：Eden, survior0（幸存者0）,survior1（幸存者1）,  注意的是，在计算内存的概念时，只有一个幸存者区是在工作的，这就是因为复制算法交替运行，因此，两个幸存者区，总有一个是空的。并且注意的是，E:s0:s1 = 8：1：1

对于堆空间的大小的参数设置：

可以通过选项："-Xms" "-Xmx"进行设置堆中的容量：

* "-Xms":是设置堆区的起始内存（ms:memory start），等价于：-XX: InitialHeapSize
* "-Xmx":是设置堆区中的最大容量，等价于 -XX: MaxHeapSize

注意的是：如果堆中内存满了后，就会抛出：OutOfMemoryError异常，对于上面还要注意的是，我们设置的参数是针对年轻代和老年代的。

默认情况下：

* 初始内存大小：物理电脑内存/64
* 最大内存大小：物理电脑内存/4

> 在实际开发中，我们一般将初始内存和最大内存设置成一致，因为如果不一致的话，当堆内存中满了的话，还要进行扩容和垃圾回收，当不需要很大的内存的话，还要释放内存，同时还有GC,就会降低执行效率。

查看堆内存的几个命令：

* jps：查看进程号
* jstat -gc 进程号：查看内存的分布情况
* -XX: +PrintGCDetails  :在控制台中查看

新生代和老年代的相关参数设置：

（生命周期比较短的放在新生代中，生命周期比较长的放在老年代）

* -XX：NewRatio=2, 表示新生代占1，老年代占2，这是默认设置，可以根据需求进行调整。
* -Xmn：设置新生代的最大内存大小，设置了之后，上面的命令就无效了，这个命令不常用了。
* -XX: Survivorratio=8 ,这个表示Eden区和survivor区的比例是8：1，不过这个设置要进行显示设置，否则可能不是这样的情况

![image-20201015153414640](img\image-20201015153414640.png)

​            ![image-20201015153447916](img\image-20201015153447916.png)

> 对上面这个过程给一个说明，并下面也有图例进行说明：首先我们会new一个对象，先将这个对象往Eden区放，当放满的时候，也就是Eden区中内存不足的时候，就会触发minor GC，进行标记并回收，然后将幸存下来的对象放入S0中，并标记年龄为1，这时E区就为空，然后接着向E区放对象，如果又满了，就触发minor GC ，就会将E/S0区中的对象进行回收（注意，这里S0是被迫回收的）将幸存下来的对象都放入S1区。并将对象的年龄+1，这时E/S0是空的，然后继续向E区放对象，所以S0/S1是交替进行工作的。当对象的年龄满了15岁，又被迫触发了GC,就要将GC放入老年代中。

下面来说明下特殊的过程：

1、如果我们new的对象比较大，放不进去E区，这时就触发E的GC,当空了的时候还是放不进去，就直接放入老年代中。

2、如果在中间的过程中S0/S1区满了后，但是S0/S1区中的对象没有满15岁，也就会将多余的对象放入老年代中，也就是触发晋升机制。

3、如果从年轻代中晋升过来的对象或者是满了15岁后的对象放到老年代时，发现老年代中空间不足，就会触发majorGC/fullGC,如果触发过后，还是放不下，就会发生OOM。

![image-20201015154727084](img\image-20201015154727084.png)

下面来讲下常用的调优的工具：

![image-20201015155246688](img\image-20201015155246688.png)

#### 15、Minor GC Major GC Full GC

![image-20201015160422392](img\image-20201015160422392.png)

![image-20201015160654856](img\image-20201015160654856.png)

> STW：是指stop the world  就是指用户线程暂停

![image-20201015161031056](img\image-20201015161031056.png)

![image-20201015161352416](img\image-20201015161352416.png)

> 上面我们讲了堆空间的分代思想，那为什么堆空间要这样分呢？不这样分行不行呢？我们所new出来的对象很大部分都是朝生夕死的，但是也有很多的大对象，也有存活时间很长的对象，试想如果每次GC的时候都要对这些对象进行标记，来观察是否回收，但是又发现不必要进行回收，这样做就会降低执行效率，况且，在回收的时候，用户线程还会被阻塞。

#### 16、TLAB

#### 17、关于对象的分配

![image-20201019091230774](img\image-20201019091230774.png)

逃逸现象概述：

![image-20201019091436929](img\image-20201019091436929.png)

**代码优化之栈上分配：**

![image-20201019092729326](img\image-20201019092729326.png)

**代码优化之同步省略（一般这个没啥用，写代码时注意下）**

![image-20201019094055249](img\image-20201019094055249.png)

![image-20201019094146100](img\image-20201019094146100.png)

**代码优化之标量替换：**

![image-20201019094849371](img\image-20201019094849371.png)

![image-20201019094736372](img\image-20201019094736372.png)

![image-20201019094933873](img\image-20201019094933873.png)

逃逸分析的一些总结：

![image-20201019095518761](img\image-20201019095518761.png)

#### 18、方法区的相关知识

![image-20201019131816148](img\image-20201019131816148.png)

方法区的基本理解

![image-20201019133935581](img\image-20201019133935581.png)

> 注意的是：方法区在逻辑上是属于堆空间的，落地实现是元空间，字符串常亮池已经移到堆空间了。



#### 19、方法区的演进

![image-20201021104252454](img\image-20201021104252454.png)

> 对于永久代和元空间这两种落地实现，还是要说明下他们的区别：
>
> 元空间的使用的内存是本地内存，如果本地内存不足会报OOM,以前永久代用的是虚拟机内存，因此是容易发生OOM的。

#### 20、方法区参数设置

![image-20201021110054219](img\image-20201021110054219.png)

![image-20201021153504518](img\image-20201021153504518.png)

如何解决内存泄露和内存溢出的问题：

![image-20201021154701668](img\image-20201021154701668.png)

> 内存泄露就是指有的对象与GC root相关联，但是后期又没有进行使用，一旦这样的对象多了后，就会导致内存泄露的问题。

#### 21、方法区的内存结构

![image-20201021155128022](img\image-20201021155128022.png)

方法区（Method Area）主要存储什么？

![image-20201021155504928](img\image-20201021155504928.png)

![image-20201021155909302](img\image-20201021155909302.png)

> 主要存自己类上面的相关信息，不包括类中的方法或者是属性。

![image-20201021160104590](img\image-20201021160104590.png)

![image-20201021160258215](img\image-20201021160258215.png)

final-static的相关理解：

![image-20201021164947550](img\image-20201021164947550.png)

![image-20201021165258348](img\image-20201021165258348.png)

> 主要说明下字符串常量池在内存中的位置：在class文件中存在常量池，被加载到内存中形成运行时常量池，自jdk1.7后，静态变量和字符串常量池就被移到了堆内存中，因为如果字符串常量池被放在元空间（本地内存）中不容易触发GC,因此就将字符串常量池放在了堆空间中，来满足开发过程中所需要的大量字符串。

#### 22、方法区中的垃圾回收

> 方法区中的垃圾回收难以令人满意，但是又是必要的，条件相当苛刻。

方法区中的垃圾回收主要分为两部分：常量池中废弃的常量（字面量和符号引用）和不再使用的类型。

主要是类的回收比较苛刻：

![image-20201026193926347](img\image-20201026193926347.png)

#### 23、方法区总结与面试题

![image-20201026194831928](img\image-20201026194831928.png)

面试题的相关：

![image-20201026195205674](img\image-20201026195205674.png)

![image-20201026195513272](img\image-20201026195513272.png)

### 4）、对象实例化与访问定位

> 面试题引子

![image-20201026200208505](img\image-20201026200208505.png)

#### 1、对象实例化

**对象实例化的几种方式:**

* 通过new关键字进行实现，这里面构造方法可以是私有的，也可以是公用的。
* 通过Class中的newInstance():反射的方式，不过这个只能对公有的进行，并且只能对默认的无参进行处理。
* 通过Constructor中的newInstance(Xxx)：反射的形式，无论公有或者私有都可以。
* 通过clone(): 不调用构造器，当前类来实现cloneanle接口。
* 反序列化：从文件中获取对象的二进制流。
* 第三方库中的实现。

**对象实例化的步骤：**

* 判断对象对应的类是否加载，链接，初始化（这块就是类加载的过程）

> 虚拟机遇到一个new指令，首先会去检查这个指令的参数能否在mateSpace的常量池中定位到这个类的符号引用，并检查这个类是否被加载，使用双亲委派机制进行加载，如果找不到这个类，就会报ClassNotFundException异常。

* 为对象分配内存（堆空间的操作）

> 首先要计算对象占用的空间大小，然后划分一块内存给对象，如果实例成员变量是引用变量，仅仅分配引用变量空间就可以了，也就是4个字节。

​         在分配的过程中，如果内存是规整的，就会指针碰撞，将内存分配到指针头上来，如果不是内存规整的，就可能是内存分配表，用来记录哪块内存可以用，再进行分配。

* 处理并发安全问题

> 采用CAS失败重试，区域加锁保证原子性，或者是每个线程预先分配一块TLAB, 通过-XX: +/-UseTLAB 参数进行设置

* 初始化分配域信息空间与值

> 所有属性设置默认值。保证对象实例字段在不赋值的时候可以使用。

* 设置对象的对象头

> 比如说会连接到类的信息之类的

* 执行init方法进行初始化

> 执行初始化代码块以及构造函数

#### 2、对象内存的结构

![image-20201029121236214](img\image-20201029121236214.png)

#### 3、对象访问定位

![image-20201029121743676](img\image-20201029121743676.png)

有两种方式：

* 句柄访问 比较稳定
* 直接指针（hotspot虚拟机使用）

### 5）、直接内存

> direct memory 直接内存属于本地内存，不属于java虚拟机里面的部分。

![image-20201029123453945](E:\myStudy\docisfy\javaLearn\docs\document\java\img\image-20201029123453945.png)

> 这里就涉及到了阻塞式访问  IO     非阻塞式访问 NIO  （netty）  

![image-20201029124013449](img\image-20201029124013449.png)

![image-20201029124228172](img\image-20201029124228172.png)

直接内存概述：

![image-20201030100033389](img\image-20201030100033389.png)

### 6）、执行引擎

#### 1、概述

![image-20201030100606433](img\image-20201030100606433.png)

> jvm的主要任务是负责将字节码加载到内部，但是字节码的执行要靠执行引擎起作用。执行引擎（Execution Engine）的作用就是将字节码指令解释/编译为对应平台上的机器指令。

#### 2、工作过程

![image-20201030101850905](img\image-20201030101850905.png)

#### 3、JIT与解释器

![image-20201030102416133](img\image-20201030102416133.png)

> 说明的是，即时编译器编译出来的机器指令是放在的方法区中的codeCache。

![image-20201030104509665](img\image-20201030104509665.png)

> 因此，在java中，就是要先将源代码编译成字节码，再通过执行引擎编译成机器指令，字节码就类似于c++中的汇编过程，但是他是二进制的。所以与平台无关性。

> 解释器分为字节码解释器和模板解释器，现在用的是模板解释器。

#### 4、解释器与即时编译器共存

> 既然即时编译器（JIT）的性能优于解释器，那么为什么还要使用解释器呢？这点下面仔细分析下。

java虚拟机运行时，解释器和即时编译器能够互相协助，各自取长补短，尽力选择最合适的方式来选择编译本地代码的时间和直接解释执行代码的时间。

![image-20201101185926744](img\image-20201101185926744.png)

#### 5、案例

![image-20201101191107550](img\image-20201101191107550.png)

> 注意这里所说的热机状态下用即时编译器效率更高，但是启动慢，因此启动的时候尽量是解释器。但是解释器执行效率低，因此执行代码的流量要低一些。

#### 6、JIT编译器

![image-20201101191601582](img\image-20201101191601582.png)

如何选择使用JIT:

热点代码及探测方式：

![image-20201101201143748](img\image-20201101201143748.png)

![image-20201101202622414](img\image-20201101202622414.png)

> 也就是说，JIT针对的是方法的执行和循环的执行。并发生栈上替换（注意区别前面讲的标量替换和对象的栈上分配）

![image-20201101203629747](img\image-20201101203629747.png)

![image-20201101205359097](img\image-20201101205359097.png)

> 也就是说，对于JIT的计数器来看，不可能是一直增长的，还是要在一定时间上来看的，因此，要具备半衰周期的，当然，这些参数是可以自行调节的。

回边计数器：

![image-20201101205706859](img\image-20201101205706859.png)

#### 7、C1与C2编译器

HotSpot VM可以设置程序执行的方式：

![image-20201101210835657](img\image-20201101210835657.png)

JIT中的两个编译器：

![image-20201101212353875](img\image-20201101212353875.png)

![image-20201101213654393](img\image-20201101213654393.png)

> 这里的话，注意前面我们所说的关于对象的一个栈上分配，标量替换的效果，就是用C2编译器执行的。

![image-20201101213808431](img\image-20201101213808431.png)

#### 8、Graal编译器与AOT编译器

**Graal编译器:**

![image-20201101215701043](img\image-20201101215701043.png)

**AOT编译器：**

![image-20201101215811548](img\image-20201101215811548.png)

![image-20201101215904582](img\image-20201101215904582.png)

### 7）、String Table相关知识

> 只记录相关不懂的地方

* String 类型是不可变类型的，主要体现在基本结构是final char数组，jdk1.9后就定义为byte类型的了。
* 另一方面，字符串常量池（现在在堆空间中) 是不会存储相同内容的字符串的。
* 对于String 的相关操作，比如replace()方法，实质上还是会new新的字符串的。
* 对于为什么要把字符串常量池放在堆空间呢？因为permSize(1.7以前)默认值是比较小的，如果出现大量的String，容易发生full GC，所以就移动到堆空间中。

#### 1、字符串常量池在内存中的表现

![image-20201102135641674](img\image-20201102135641674.png)

> 注意各个版本时的字符串常量池的容量问题。

如何定义一个String类型的数据呢？

* 通过new关键字
* 通过直接字面量的形式
* 通过intern()方法实现

#### 2、字符串拼接的相关操作

![image-20201103131936807](img\image-20201103131936807.png)

> 对于intern()方法，这里做一个说明：比如对s1.intern()为例，如果字符串常量池中 没有s1的值，就加载一份到常量池中，并返回字符串常量池的地址，如果常量池中有该字符串，就返回常量池中字符串的地址。

对于字符换的拼接问题，做下面的说明：

* 如果拼接的字符串中含有变量，就会new StringBuilder做拼接操作（1.5后，1.5前是StringBuffer.
* 如果拼接的字符串中是字符常量，或者是引用常量，就会在编译器做优化，并不会用Builer做拼接操作。

下面代码说明例子：

```java
String s1 = "a";
final String s2 = "b";
String s3 = "ab";
String s4 = "a" + s2;
System.out.println(s3 == s4);   //true  这里使用的是final常量引用，直接做优化

String s5 = "c";
String s6 = "d";
String s7 = "cd";
String s8 = s5 +s6;
System.out.println(s7 == s8);  //false   这里使用的是变量
```

> 下面对字符串拼接使用append()好还是使用 + 运算符好呢？下面我们做分析：

对于拼接操作，其原理就是要构造new StringBuilder 以及使用toString()来new String，而对于append()方法，只需要使用一次的StringBuilder,这对于多次循环的字符串拼接在效率上有很大的提升，从内存结构上来看，多次的new对象，会造成GC,影响内存，当然使用StringBuilder的append()方法还是有改进的地方，我们清楚的是，StringBuilder以及String底层都是char数组，那么就涉及到扩容的问题，如果多次扩容，也会造成内存满了，并进行GC,如果在初始化new StringBuilder的时候，我们就考虑到字符串内容，就能预先设置数组长度，从而进一步优化。

#### 3、intern()方法在jdk6 /78中差异

```java
String s1 = new String("a") + new String("b");
```

> 首先对这行代码做一个简单的说明吧，对于这个操作，最后要记住的是，并没有在字符串常量池中创建对象，这里就仅仅是在堆空间创建了值为ab的String对象。

接下来说明下intern()方法的执行：

* 在jdk6中，字符串常量池在永久代中，而建立的对象是在堆中，因此，在执行intern(),是将对象中的值与永久代中的字符串常量池中的值进行比较进行存储。
* **在jdk7/8中，intern()方法的执行，如果字符串常量池中没有该字符串，是将对象的引用放在了常量池中的。**

> 上面这点很重要。要记住，另外，intern()是有返回值的，返回的是在字符串常量池中创建的那个。

![image-20201103202104726](img\image-20201103202104726.png)

intern的效率测试：

![image-20201103212419584](img\image-20201103212419584.png)

> 更加节省空间，直接使用字符串常量池中的对象，对于新建在堆中的，所以这里存在GC。

#### 4、G1的String去重操作

![image-20201103213840730](img\image-20201103213840730.png)

![image-20201103214935044](img\image-20201103214935044.png)

![image-20201103215119967](img\image-20201103215119967.png)



## 其他

简单理解下垃圾回收机制

对于垃圾回收机制，就是说没有引用的对象要被清理掉。

那么怎么来判别对象有没有引用呢？

两种方式：

* 引用计数法，当被引用，就对对象标记+1，减少了一次引用，就-1，但是会造成循环引用的问题。
* 可达性分析，也就是要找GC root，对于根引用是GC root内的，就保留，否则，就进行清理。

什么是GC root内的呢？

虚拟机方法栈中的局部变量表中的，本地方法栈中的，方法区中静态属性，常量属性的。

那么怎么进行的垃圾回收的呢？三个算法：

* 标记-清理算法：对能够间接或者直接可达GC root的对象进行标记，如果没被标记，就要进行清理。
* 标记-整理算法：对于标记清理，会产生碎片内存，因此，整理算法就要对内存进行整理，当然，整体的移动，会非常的消耗内存。
* 复制算法：就是将对象清理后，将活下来的对象保存到另一块内存空间中。

堆内存中的具体：

![IMG_20201014_221045](img\IMG_20201014_221045.jpg)

jdk8开始，永久代被元空间取代。

