# JAVA虚拟机

## 一、内存与回收机制

### 1、JVM及其体系结构

![image-20200917152216078](img\image-20200917152216078.png)

相关的概念： 

   *    OOM :  内存的溢出问题
   *    GC : 垃圾回收机制

结构层次：  高级语言---->  汇编语言 -------> 及其指令------> CPU

对比于c++,java能动态分配内存，以及具备垃圾回收机制，但是在c++中，我们都是由程序员来进行分配内存和回收垃圾。

#### 1、跨平台

java结尾的源文件，生成字节码文件（.class），然后在不同的JVM上去运行。

![image-20200922130459437](img\image-20200922130459437.png)

在java虚拟机平台上可以运行非java语言编写的程序，值得注意的是：java虚拟机并不关心在其内部运行的程序到底是何种语言编写的，它只关心“字节码”文件，只要其他编程语言的编译结果满足并包含java虚拟机的内部指令集，符号，及其他的辅助信息，他就是一个有效的字节码文件，就能被识别并装载运行。

#### 2、虚拟机

虚拟机可以分为系统虚拟机和程序虚拟机

* 系统虚拟机也就是Visual Box, VMware,这类就属于系统虚拟机，是在操作系统之上的软件层面对物理计算机的仿真，
* 程序虚拟机的典型带边就是java虚拟机，专门为执行单个计算机程序而设计的，**在java虚拟机中执行的指令我们成为java字节码指令**（javac编译之后形成的）。

#### 3、整体结构

![image-20200927145326480](img\image-20200927145326480.png)

> 个小部分的简单说明与介绍： 代码文件（.java） 通过前端编译器（javac）产生字节码文件（.class）,然后通过我们的类加载机制，加载到运行时数据区（内存空间），运行时数据区主要包含（方法区【method Area】，堆【heap】, java栈【java stack】, 本地方法栈【Native Method Stack】,程序技术器【Program Counter Register】) 值得注意的是，堆和方法区是多线程共享的。然后通过执行引擎（Execution Engine）翻译成机器指令供操作系统执行。

#### 4、执行流程

![image-20200927150640015](img\image-20200927150640015.png)



#### 5、相关指令

对于JVM来讲，是基于栈进行的，对于类似安卓系统来讲，是基于寄存器进行的。

> 这里顺便解释下为什么说java是解释性的语言，通过前面的学习，我们知道.java文件即使是被编译成.class，但是还是不能够被机器执行的，是需要通过jvm中的执行引擎通过逐一的解释，执行，才能被执行，因此，才说java是解释性的语言，所以，这里就有了前端编译器和后端解释器的概念。

栈：跨平台性，指令集小，指令多，执行性能比寄存器差。

这里先了解个概念：

关于反编译：也就是将class文件反编译成我们能够看的懂的源文件，有什么jad呀以及其他的什么之类的，以及我们的命令行参数javap命令，在相关的.class目录下使用命令 javap - v  program.class，就会生成相应的源文件码来使用。

#### 6、JVM的生命周期

**虚拟机的启动**：

* java虚拟机的启动时通过引导类加载器（bootstrap loader）创建一个初始类（initial class） 来完成的，这个类是由虚拟机的具体实现指定。

**虚拟机的执行：**

* 一个运行的java虚拟机有若干个清晰的任务：执行java程序。
* 程序开始执行时他才运行，程序结束时他就停止。
* 执行一个所谓的java程序时候，真真正正在执行的是一个java虚拟机的进程。

**虚拟机的退出：**

* 程序正常执行结束
* 程序在执行的过程中遇到异常或错误而异常终止
* 由于操作系统出现错误而导致java虚拟机进程终止。
* 某线程调动Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作。



堆内存中存储的是new 出来的东西

方法区里面存储的是字节码

方法栈中存储的是方法，在被调用的时候使用，方法中的字面量存储在方法栈中，如果是引用数据类型，存储的是堆中的地址。

#### 7、常见的JVM版本

* Sun Classic VM: 最早的java虚拟机，执行引擎分由解释器（逐行进行解释）和JIT（just-in-time compilation）及时编译器（快速编译形成热点代码，并将机器指令存储在内存缓存中）组成，但是不能交替工作，只能单独工作，JIT是通过外挂的形式进行工作，不能识别数据是引用的地址还是基本数据类型。
* Exact VM :编译器能够与JIT混合工作，提升其效率，能够分别数据与引用，还具有热点探测的功能。
* BEA   JRockit : 牺牲了解释器，用JNT的模式 进行工作，常用在服务器端，是运行最快的虚拟机。
* Hotspot : 也就是我们最常见的。
* J9: 这个是IBM公司开发的，一般来说主要是公司内部产品的底层工具，性能较好，未开源。
* 以及其他的一些。

### 2、类加载子系统（class loader subSystem）

![image-20200930091742907](img\image-20200930091742907.png)

![image-20200930092318302](img\image-20200930092318302.png)

加载的过程：

![image-20201009091651571](img\image-20201009091651571.png)

#### 1、加载阶段

* 通过一个类的权限定名获取此类的二进制字节流
* 将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

![image-20201009092936825](img\image-20201009092936825.png)

#### 2、链接阶段

> 链接包含 验证（Verify），准备(Prepare)，解析(Resolve)

![image-20201009094739118](img\image-20201009094739118.png)

> 1、所谓验证，就是要在二进制流加载的过程中检验其字节码文件的合法性，class文件，也就是JVM所识别的文件，都会有一个 CA FE BA BE 的关键字节码。2、准备中的赋予初值要注意，如有：static int i = 1;是先赋值为0，在初始化阶段再赋值为1的。

#### 3、初始化阶段

![image-20201009095621706](img\image-20201009095621706.png)

对于执行<clinit>()方法的过程，我们用个例子来说明：

```java
public class MyTest {

    public static int num = 1;
    static {
        num = 5;
        number = 20;
        //System.out.println(number);   //非法向前引用
    }

    public static int number = 10;


    public static void main(String[] args) {
        System.out.println(MyTest.num);   //5
        System.out.println(MyTest.number);  //10
    }
}
```

> 在链接的准备阶段，对num=0;   number=0进行赋初值，然后到初始化阶段，执行<clinit>()进行赋值操作，num先赋值为1，然后赋值为5，number先赋值为20，然后赋值为10，注意的是，虽然可以进行赋值的左操作，但是不能进行右操作。同时，如果该类中没有静态变量，就不会执行<clinit>()函数。

关于多线程，指的是加载类的操作仅仅只会执行一遍，而不会执行多次。下面举个例子：

```java
/*
 *@author by java开发-曾
 *2020/9/26 16:11
 *文件说明：
 */
public class MyTest implements Runnable{

    public static void main(String[] args) {
       Runnable r = new Runnable() {
           @Override
           public void run() {
               System.out.println(Thread.currentThread().getName()+"开始");
               //类在线程中被加载
               Run run = new Run();
               System.out.println(Thread.currentThread().getName()+"结束");
           }
       };

       Thread th1 = new Thread(r,"线程1");
        Thread th2 = new Thread(r,"线程2");

        th1.start();
        th2.start();

    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"开始");
        //类在线程中被加载
        Run run = new Run();
        System.out.println(Thread.currentThread().getName()+"结束");
    }
}

class Run{

    static {
        if(true){
            System.out.println("该类被加载"+Thread.currentThread().getName());
            while (true){

            }
        }

    }
}

//运行结果
线程1开始
线程2开始
该类被加载线程1
```

#### 4、关于加载器的简介

> 类在被加载的过程，我们对加载器进行分类，分为两种 ：bootStrapClassloader(引导类加载器) 和 自定义加载器，
>
> 对于引导类加载器，他是使用c++/c语言编写的，对于自定义加载器，是直接或者间接的继承了Classloader,是在java中可以具体实现的。对于这几类加载器，是没有具体的继承等关系的，但是有上下级的关系。具体在下面的代码中可以看出：

```java
//获取系统类加载器
ClassLoader appClassloader = ClassLoader.getSystemClassLoader();
System.out.println(appClassloader);  //  sun.misc.Launcher$AppClassLoader@18b4aac2

//获取上层的扩展类加载器
ClassLoader exClassLoader = appClassloader.getParent();
System.out.println(exClassLoader);  //  sun.misc.Launcher$ExtClassLoader@1b6d3586

//获取上层的引导类加载器
ClassLoader bootClassloader = exClassLoader.getParent();
System.out.println(bootClassloader); //null: 因为引导类加载器是用c++/c 进行编写的
                                     //已经超出了java的范畴，是获取不到该对象的。

//看下我们具体使用的类是用哪些加载器来加载的

//我们的自定义类：MyTest  可以看出是用的系统类加载器
ClassLoader classLoader = MyTest.class.getClassLoader();
System.out.println(classLoader);   //sun.misc.Launcher$AppClassLoader@18b4aac2

//在看看我们的String  使用的是引导类   值得注意的是，我们java中的核心类库都是由引导类加载器进行加载的
ClassLoader classLoader1 = String.class.getClassLoader();
System.out.println(classLoader1);  //null
```

具体的介绍：

![image-20201009144559325](img\image-20201009144559325.png)

![image-20201009145113009](img\image-20201009145113009.png)

![image-20201009145543640](img\image-20201009145543640.png)

获取加载器加载的路径：

```java
//获取引导类加载器的类文件的目录
  URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
  for (URL urL : urLs) {
      System.out.println(urL);
  }

  //同样，我们也可以来查看扩展类加载器加载的目录结构是什么
  String property = System.getProperty("java.ext.dirs");
  for (String url: property.split(";")) {
      System.out.println(url);
  }
```

![image-20201009151508212](img\image-20201009151508212.png)

![image-20201009152029560](img\image-20201009152029560.png)

#### 5、双亲委派机制

> java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成的class对象中，而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，他是一种任务委派模式。

![image-20201009154453028](img\image-20201009154453028.png)

优势：

* 避免类被重复加载
* 起保护作用，比如自定义类的包名为java.lang ,但是引导类加载器具有权限，因此是不能被加载的。

#### 6、沙箱安全机制

一、概念

保证对java核心源代码的保护，就是沙箱安全机制。
就是一种保护机制，保护源代码，保护JVM不受恶意代码的破坏。

二、示例

自定义的String类（java.lang.String），但是加载自定义类的时候回率先使用引导类加载器加载，而引导类加载器在加载的时候先加载jdk自带的文件(rt.jar包中的java\lang\String.class)，不会加载自定义的String类，这样就保护了java的源码，不会受到污染。

#### 7、其他

1）在JVM中表示两个class对象是否为同一个类存在的必要条件：

* 类的完整类名必须一致，包括类名
* 加载这个类的Classloader(指ClassLoader实例对象)必须相同

> 换句话说，在JVM中，即时这两个类对象(class对象)来源于同一个class文件，被同一个虚拟机加载，但是加载器不同，两个类对象也是不相等的。

![image-20201009201637316](img\image-20201009201637316.png)

类的主动使用与被动使用

![image-20201009202132269](img\image-20201009202132269.png)

### 3、运行时数据区概述及线程

#### 1、简介

![image-20201009203817985](img\image-20201009203817985.png)

![image-20201009204406992](img\image-20201009204406992.png)

#### 2、程序计数器

> program Counter Register  :程序计数寄存器。主要存储指令相关的现场信息，cpu只有把数据装载到寄存器中才能运行。

![image-20201012213024976](img\image-20201012213024976.png)

![image-20201012213237301](img\image-20201012213237301.png)

![image-20201012213540995](img\image-20201012213540995.png)

> 也就是说，pc是不存在垃圾回收的，也是不存在内存溢出的，但是本地方法栈和虚拟机栈是可能出现内存溢出的（当栈满的时候）

PC寄存器的一个大致流程：

![image-20201012214754418](img\image-20201012214754418.png)

关于PC寄存器的两个问题：

![image-20201012215204130](img\image-20201012215204130.png)

#### 3、虚拟机栈

1）虚拟机栈出现的背景：

![image-20201012220527061](img\image-20201012220527061.png)

> 栈是运行时的单位，而堆是存储的单位

![image-20201012221407092](img\image-20201012221407092.png)

> 注意的是：这里说明的局部变量，要与成员变量（属性）有所区分，局部变量又分为8种基本数据类型和引用类型变量（类，数组，接口） 所以如果是引用类型，就是引用地址。

方法的执行就是入栈的操作，执行结束就是出栈操作：

![image-20201012221929302](img\image-20201012221929302.png)

> 对于栈来讲，并不存在垃圾回收的问题，但是存在OOM(栈溢出),

![image-20201013101530959](img\image-20201013101530959.png)

![image-20201013101818156](img\image-20201013101818156.png)

> 在栈中不断去自己调用自己，也就会重复出现局部变量表，如果死循环，就会造成栈溢出，所以诸如递归等都要向已知的方向走。

如何查看或者设置栈的内存大小呢？

![image-20201013103432560](img\image-20201013103432560.png)

> 因此，对于栈空间的调优，就可以使用 -Xss来设置栈空间的大小的问题。

2）栈的存储单位

> 每个线程都有自己的栈结构，在栈中的基本单位是栈帧（stack Frame）的格式存在，每个方法都对应着一个栈帧。
>
> 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

这里要注意的是，java方法中有两种返回函数的形式，

* 一种是正常的函数返回，使用return指令。
* 另一种是抛出异常，不管使用哪种方式，栈帧都会被弹出

> 这里要强调的是，如果方法的返回值是void,也可以在方法结束后使用 return ;但是没有返回值，因为反编译的源码上每个方法都是有一个return操作的，另外，对抛出异常，会向上层方法进行异常的抛出。

3）栈帧的内部结构

![image-20201013142901926](img\image-20201013142901926.png)

> 局部变量表： 局部变量表被称为局部变量数组，或本地变量表
>
> 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括基本数据类型，对象引用，以及returnAddress类型
>
> 定义在线程内部，不存在数据安全的问题
>
> 局部变量表所需的容量大小是在编译期确定的，并保存在方法Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部标量表的大小的。

> 这里需要注意的是，当一个线程的栈的容量固定后，如果我们每个栈帧的局部标量表的容量很大的话，就会减少栈帧的数目，方法的嵌套就会减少。

关于Slot的理解：

![image-20201013151739078](img\image-20201013151739078.png)

> 引用数据类型也是占用的32位，1个Slot。

![image-20201013152643654](img\image-20201013152643654.png)

> 对于静态方法不能用this，一方面来讲，this表示当前对象，不能放在静态方法，另一种层面来讲，虚拟机栈帧中的局部变量表中是没有声明这样的一个变量的。

Slot的重复利用的问题

> 栈帧中的局部变量表的槽位是可以进行重复利用的，如果一个局部标量过了作用域，那么在其作用域之后申明的新的局部变量就很可能会重复过期的局部标量的槽位，从而节约资源。

```java
public static void main(String[] args) throws FileNotFoundException {
   int a = 1;
    {
        int b = 3;
        a = b;
    }
    //b的作用域结束了后，后面定义的变量就会复用b的局部变量表的空间
    int c = 4;
    System.out.println(a);

}
```

![image-20201013154405329](img\image-20201013154405329.png)

> 针对局部变量的一个说明：局部变量必须进行显示赋值，因为在表中药存储值，并没有默认赋值的操作，对于静态变量，前面说了会在类的加载过程中进行赋值的操作，对于实例变量来说，会在堆空间中进行初始化赋值。

> 补充说明：在栈帧中，与性能调优关系最为密切的部分就是局部变量表，在执行方法时，虚拟机使用局部变量表完成方法的传递。
>
> 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

#### 4、操作数栈

> 操作数栈（Operand stack） 使用数组来实现的，也可以叫表达式栈，用来存储临时值。

![image-20201013163616157](img\image-20201013163616157.png)

> 上面这种字节码基于操作数栈的执行过程中，可以说java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈

![image-20201013164654758](E:\myStudy\docisfy\javaLearn\docs\document\java\img\image-20201013164654758.png)

代码进行测试：

```java
public void tesyt(){
    
    /*
    0 aload_0 :加载this
    1 invokevirtual #4 <MyTest.Sum>:执行栈中的函数
    这个函数执行后，会将返回值存入到栈的栈顶中
    4 istore_1  :取出栈顶的值，将值保存到局部变量表中
    5 return
     */
    int i = Sum();
}


public int Sum(){

    //对应的解析字节码
    /*
    bipush 10 :将byte类型向int类型转换 push到操作数栈中
    istore_1 : 将栈顶的值存储到局部变量索引为1的位置处
    并进行出栈操作
     */
    byte i = 10;

    /*
    bipush 20 :将byte类型向int类型转换 push到操作数栈中
    istore_2 : 将栈顶的值存储到局部变量索引为2的位置处
    并进行出栈操作
     */
    int j = 20;

    /*
      iload_1: 将局部变量表中1位置的数压到栈中：10
      iload_2：将局部变量表中2位置的数压到栈中：20
      iadd  :进行出栈相加的操作，并将结果进行入栈
      istore_3：出栈，存储到局部变量3
     */
    int k = i+j;

    /*
     iload_3: 加载
     并将值进行返回
     */
    return k;

}
```

#### 6、栈顶缓存技术

> 栈顶缓存技术（Top-of-stack cashing）

![image-20201013182053457](img\image-20201013182053457.png)

> 也就是说，更多的入栈出栈操作由于没有地址，因此会形成更多的指令。指令更多，访问的速度就变得慢了。

#### 7、动态链接

> 指向运行时常量次的方法引用，也就是说我们把类加载到运行时数据区时，类中的方法和变量保存到运行时常量池中。在使用这些的时候就需要动态链接去引用。

![image-20201013184448863](E:\myStudy\docisfy\javaLearn\docs\document\java\img\image-20201013184448863.png)

#### 8、方法的调用

![image-20201014130550851](img\image-20201014130550851.png)

> 注意的是：这里对静态链接也称为非虚方法，动态链接也称为虚方法，，非虚方法包括：父类的构造方法，final，static，private修饰的方法。也可以称为静态绑定和动态绑定，或者前期绑定与后期绑定。

![image-20201014132825802](img\image-20201014132825802.png)

> 对于invokedynamic指令，这个是jdk1.7之后才出现的，是java为实现动态类型语言的支持做的一种改进。但是找各种指令，到1.8的时候才有了最直接的表现，如lambda（函数式编程），注意的是，像这种修改，实际上是对jvm规范的修改，并没有对语言进行改写。

动态语言与静态语言：

上面我们说到了静态语言和动态语言，对于静态语言来说，就是在编译期间就能确定判断变量自身的类型信息，而动态语言就是判断值的类型信息，所以说，Java就是静态语言，而像javascript  python 就是动态语言，比如js: 定义变量是var/let 并不知道是什么类型，在运行时，系统才知道。而python就做的更加的彻底。

#### 9、方法重写的本质

* 首先找到栈顶的第一个元素的对象的实际类型，（这里说明下声明类型（前面的定义）和实际类型（后面的new））为c。
* 如果类型c中找到与常量中描述相符合的方法，解酒进行访问权限验证，并进行访问，如果结束，不通过，就返回异常，
* 否则，就暗战继承关系从下往上依次对C的各个父类进行搜索和验证。
* 如果始终没有找到，就返回异常。

由于这种方法使用每次都要去搜索和验证，降低了性能，因此，在类的方法区中会建立一个虚方法表，直接将类中的虚方法和非虚方法存起来，如果是继承的没有重写的方法，就保存该方法的索引位置，如果重写了，就访问其直接引用地址。

#### 10、方法返回地址

就是指在return的执行过程中，会保存着嵌入这个方法的下一条指令，因为方法结束后要出栈，并且要执行外层的方法，因此，pc计数器要知道指令应该怎么去执行。

#### 11、栈中的附加信息

在很多的网上贴中，会将方法返回地址，动态链接，附加信息，统称的叫做帧数据区。对于部分的jvm来讲，可能是没有附加信息的，这个知道就行了。

#### 12、常见的栈面试题

1）举例栈溢出的情况

> 前面讲过，栈的深度如果是固定的，那么当栈帧比较多的时候，再向栈中放栈帧就会出现栈溢出（stackOverFlow） 如果是动态分配，当内存不足够进行分配时，也就会出现内存溢出。

2）调整栈的大小，就能保证不出现溢出吗？

> 不能，如果是循环迭代，并且是无限循环的，就不能保证栈的溢出了。

3）分配的栈的内存越大越好吗？

> 不是，对于他自身来讲，肯定是越大越好，但是对于其他的如堆，方法区来讲，就不是了。

4）垃圾回收机制是否会涉及到虚拟机栈？

> 不会涉及，他只有入栈和出栈的操作，只会有内存溢出的情况。

5）方法中定义的局部变量是否线程安全？

> 对于局部变量，首先是内部定义，内部销毁，才是线程安全的，否则都不是，如形式参数中的，如通过return进行返回了的。

#### 13、本地方法栈的理解

> 首先要明确的是，本地方法接口这个概念，就是比如在Object类中，在Thread类中出现的用native修饰的方法接口，他的实际上是用c/c++进行编写的，通过这个接口会去调用本地的方法类库，那这个有什么用呢？比如说访问硬件上面的东西，或者硬件中c已经实现的东西。

对于本地方法栈，具体来讲是和虚拟机栈的区别不是很大，数据结构来讲，都是用栈来实现的。

#### 14、堆的相关

> 堆也是属于运行时数据区中的一块，堆在启动时被创立，大小是确定的，是最大的内存空间，当然，堆内存是可以通过参数进行调节的。堆在物理存储上是不连续的，但是在逻辑上是连续的，这种形式是通过物理与逻辑建立映射表来实现的。

另外一个点是：TLAB: 为每一个线程分配一块堆内存空间，是独享的。（私有缓冲区）

所有的线程共享堆空间，因此，堆是属于进程级别的，在java中，对象被创建在堆中，（逃逸现象出现时，可能创建在栈中），当堆中的内存满了后，就会被GC所回收。

关于堆的内存结构的说明：（分代收集理论设计）

在jdk7及以前： 新生代（年轻代）+老年代（养老区）+永久代(Prem)（这个概念虽然属于堆，但是不完全归堆管）

在jdk8及以后：新生代（年轻代）+老年代（养老区）+元空间(meta space)（这个概念虽然属于堆，但是不完全归堆管，这个是在方法区中的落地实现的）

而新生代又分为：Eden, survior0（幸存者0）,survior1（幸存者1）,  注意的是，在计算内存的概念时，只有一个幸存者区是在工作的，这就是因为复制算法交替运行，因此，两个幸存者区，总有一个是空的。并且注意的是，E:s0:s1 = 8：1：1

对于堆空间的大小的参数设置：

可以通过选项："-Xms" "-Xmx"进行设置堆中的容量：

* "-Xms":是设置堆区的起始内存（ms:memory start），等价于：-XX: InitialHeapSize
* "-Xmx":是设置堆区中的最大容量，等价于 -XX: MaxHeapSize

注意的是：如果堆中内存满了后，就会抛出：OutOfMemoryError异常，对于上面还要注意的是，我们设置的参数是针对年轻代和老年代的。

默认情况下：

* 初始内存大小：物理电脑内存/64
* 最大内存大小：物理电脑内存/4

> 在实际开发中，我们一般将初始内存和最大内存设置成一致，因为如果不一致的话，当堆内存中满了的话，还要进行扩容和垃圾回收，当不需要很大的内存的话，还要释放内存，同时还有GC,就会降低执行效率。

查看堆内存的几个命令：

* jps：查看进程号
* jstat -gc 进程号：查看内存的分布情况
* -XX: +PrintGCDetails  :在控制台中查看

新生代和老年代的相关参数设置：

（生命周期比较短的放在新生代中，生命周期比较长的放在老年代）

* -XX：NewRatio=2, 表示新生代占1，老年代占2，这是默认设置，可以根据需求进行调整。
* -Xmn：设置新生代的最大内存大小，设置了之后，上面的命令就无效了，这个命令不常用了。
* -XX: Survivorratio=8 ,这个表示Eden区和survivor区的比例是8：1，不过这个设置要进行显示设置，否则可能不是这样的情况

![image-20201015153414640](img\image-20201015153414640.png)

​            ![image-20201015153447916](img\image-20201015153447916.png)

> 对上面这个过程给一个说明，并下面也有图例进行说明：首先我们会new一个对象，先将这个对象往Eden区放，当放满的时候，也就是Eden区中内存不足的时候，就会触发minor GC，进行标记并回收，然后将幸存下来的对象放入S0中，并标记年龄为1，这时E区就为空，然后接着向E区放对象，如果又满了，就触发minor GC ，就会将E/S0区中的对象进行回收（注意，这里S0是被迫回收的）将幸存下来的对象都放入S1区。并将对象的年龄+1，这时E/S0是空的，然后继续向E区放对象，所以S0/S1是交替进行工作的。当对象的年龄满了15岁，又被迫触发了GC,就要将GC放入老年代中。

下面来说明下特殊的过程：

1、如果我们new的对象比较大，放不进去E区，这时就触发E的GC,当空了的时候还是放不进去，就直接放入老年代中。

2、如果在中间的过程中S0/S1区满了后，但是S0/S1区中的对象没有满15岁，也就会将多余的对象放入老年代中，也就是触发晋升机制。

3、如果从年轻代中晋升过来的对象或者是满了15岁后的对象放到老年代时，发现老年代中空间不足，就会触发majorGC/fullGC,如果触发过后，还是放不下，就会发生OOM。

![image-20201015154727084](img\image-20201015154727084.png)

下面来讲下常用的调优的工具：

![image-20201015155246688](img\image-20201015155246688.png)

#### 15、Minor GC Major GC Full GC

![image-20201015160422392](img\image-20201015160422392.png)

![image-20201015160654856](E:\myStudy\docisfy\javaLearn\docs\document\java\img\image-20201015160654856.png)

> STW：是指stop the world  就是指用户线程暂停

![image-20201015161031056](img\image-20201015161031056.png)

![image-20201015161352416](img\image-20201015161352416.png)

> 上面我们讲了堆空间的分代思想，那为什么堆空间要这样分呢？不这样分行不行呢？我们所new出来的对象很大部分都是朝生夕死的，但是也有很多的大对象，也有存活时间很长的对象，试想如果每次GC的时候都要对这些对象进行标记，来观察是否回收，但是又发现不必要进行回收，这样做就会降低执行效率，况且，在回收的时候，用户线程还会被阻塞。

#### 16、TLAB

#### 17、关于对象的分配

![image-20201019091230774](img\image-20201019091230774.png)

逃逸现象概述：

![image-20201019091436929](img\image-20201019091436929.png)

**代码优化之栈上分配：**

![image-20201019092729326](img\image-20201019092729326.png)

**代码优化之同步省略（一般这个没啥用，写代码时注意下）**

![image-20201019094055249](img\image-20201019094055249.png)

![image-20201019094146100](img\image-20201019094146100.png)

**代码优化之标量替换：**

![image-20201019094849371](img\image-20201019094849371.png)

![image-20201019094736372](img\image-20201019094736372.png)

![image-20201019094933873](img\image-20201019094933873.png)

逃逸分析的一些总结：

![image-20201019095518761](img\image-20201019095518761.png)

#### 18、方法区的相关知识

![image-20201019131816148](img\image-20201019131816148.png)

方法区的基本理解

![image-20201019133935581](img\image-20201019133935581.png)

> 注意的是：方法区在逻辑上是属于堆空间的，落地实现是元空间，字符串常亮池已经移到堆空间了。











## 其他

简单理解下垃圾回收机制

对于垃圾回收机制，就是说没有引用的对象要被清理掉。

那么怎么来判别对象有没有引用呢？

两种方式：

* 引用计数法，当被引用，就对对象标记+1，减少了一次引用，就-1，但是会造成循环引用的问题。
* 可达性分析，也就是要找GC root，对于根引用是GC root内的，就保留，否则，就进行清理。

什么是GC root内的呢？

虚拟机方法栈中的局部变量表中的，本地方法栈中的，方法区中静态属性，常量属性的。

那么怎么进行的垃圾回收的呢？三个算法：

* 标记-清理算法：对能够间接或者直接可达GC root的对象进行标记，如果没被标记，就要进行清理。
* 标记-整理算法：对于标记清理，会产生碎片内存，因此，整理算法就要对内存进行整理，当然，整体的移动，会非常的消耗内存。
* 复制算法：就是将对象清理后，将活下来的对象保存到另一块内存空间中。

堆内存中的具体：

![IMG_20201014_221045](E:\myStudy\docisfy\javaLearn\docs\document\java\img\IMG_20201014_221045.jpg)

jdk8开始，永久代被元空间取代。

