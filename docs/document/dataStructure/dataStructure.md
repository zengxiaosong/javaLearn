# 数据结构分析

## 一、排序算法

排序方法有很多种，这里只是介绍几种常用的排序方法如：冒泡排序

### 1、冒泡排序（升序）

> 简单说明：每次通过循环比较，将最大的数放到最后面，进行重小到大的排序

实现原理： 1、每次循环对前后两个数进行大小比较，然后对数值进行交换，全部值比较后最大的数字就会到最后去。

​					 2、对前面的n-1个数字按照 1 中进行比较，得出最大值，

​					 3、循环进行比较，直到比较前面2个数进行比较，到这里就比较了n-1次，每次的比较的数字也从n到2，

按照上面的这种方式就能得出冒泡排序的实现方法了。

**数组实现冒泡排序**：

```java
public static void main(String[] args) {
    int [] nums = {98,25,89,14,56,84,32,12};
    //设计排序的方法，升序设计,对数组的地址值进行改变，不用返回值
    sortArrays(nums);
    System.out.println(Arrays.toString(nums));
}
private static void sortArrays(int[] nums) {
    //排序进行比较的次数为n-1次
    for (int i = 0; i <nums.length-1 ; i++) {
        //比较的数从最后到前面依次减少
        for (int j = 0; j <nums.length-1-i; j++) {
            //前后两个数进行比较
            if (nums[j]>nums[j+1]){
                int thrid = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = thrid;
            }
        }
    }
}
```

> 按照上面的算法，排序要经过（n-1）+(n-2) +  ....+2+1 = n(n-1)/2 ,忽略量级的话，那么`时间复杂度也就是 O(n^2)`

**稳定性：**

在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序。

> 说到稳定性，就来讲下什么是稳定性：比如说对  5  3   5  2     进行排序，现在我们将后面的5定义成 5·   得出是：
>
> 5 3  5·  2   ,在第一次进行排序的时候，得到结果 2 3 5·  5   这里可以看出两个5的顺序有了明显的改变，两个数字的权值发生了改变，因此这种状况下，是不稳定的。

**使用场景：**

冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于`算法复杂度较高`，在数据量大的时候不适合使用。

### 2、选择排序（升序）

实现原理：   对最开始的元素做标记，与后面的数进行比较，进行交换，将最小的数放在前面。

				*  1、将剩余元素中最小的元素与首元素进行交换
				*  首位元素下标+1，

经过n-1次的选择比较就能得到排序的结果了

**使用数组实现过程**：

```java
public static void main(String[] args) {
        int [] nums = {98,25,89,14,56,84,32,12,420};
        //设计排序的方法，升序设计,对数组的地址值进行改变，不用返回值
        sortArrays(nums);
        System.out.println(Arrays.toString(nums));
    }
    private static void sortArrays(int[] nums) {
        //使用选择排序的方法设计实现
        for (int i = 0; i <nums.length-1 ; i++) {
            //标记首位元素下标
            int min = i;
            //查找出剩余元素中最小的值的下标
            for (int j = min+1; j <nums.length ; j++) {
                //如果后面的元素小于首元素，就将最小值的下标进行替换
                //这里仅仅是获得了每次比较最小值的下标，因此比较也是同下标得出来的值进行比较
                if(nums[j]<nums[min]){
                    min=j;
                }
            }
            //找到最小的元素下标后,将最小元素放在首位
            if(i!=min){
                int thrid = nums[i];
                nums[i] = nums[min];
                nums[min] = thrid;
            }
        }
}
```

> 同上面一样，时间复杂度同样是（n-1）+(n-2) +  ....+2+1 = n(n-1)/2 ,忽略量级的话，那么`时间复杂度也就是O(n^2)`

**稳定性：**

用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的。
不过，一般提到排序算法时，大家往往会默认是数组实现，所以选择排序是**不稳定**的。

**适用场景：**

选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。

### 3、插入排序（升序）

算法描述：

​        对于插入排序，其实现是通过构建有序列，将未排序的数，通过从后往前扫描已经排序好的数列来实现，比较直观。

* 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。

* 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。

* 重复上述过程直到最后一个元素被插入有序子数组中。

稳定性：

> 由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是**稳定的**排序方法。

适用场景：

> 插入排序由于O( n2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。例如，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。又如，在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。

实现代码：

```java
private static int[] insertSort(int[] nums) {
      //对要将后面要插入的数字进行排序，一共n-1个数
    for (int i = 1; i <nums.length; i++) {
        //在插入的时候，可能会遇到本地址的值被顶替，因此先保存值
        int value = nums[i];
        //定义要排列的数目前所在的位置
        int position = i;
        //进行循环插入值
        while (position >0 && value<nums[position-1]){
            //当小于的时候，我们将继续判断是否小于上一位，如果继续小于，就往前移动。
            //最多和第一位进行比较，因此 所在的位置最多在第二位，也就是1 > 0
            //当小于末尾的数字时，就将末尾的数字往后移动，
            nums[position] = nums [position-1];
            position--;
        }
        //退出循环，当不小的时候
        nums[position] = value;
    }
    return nums;
}
```

### 4、快速排序 （升序）

快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。

**算法描述：**

* 首先从需要进行排序的数列中选出一个数（随机）作为基准（pivot）,一般选左边第一个。
* 然后将基准挑出来，将左边第一个定位left. 右边第一个定位right, 让两个指针向中间移动，如果right上的数小于基准，就放到left上面，然后left移动，如果left上的数大于基准，就放到right上，当两个指针相遇时，就将基准放到上面。
* 完成上面的操作后，就将左边和右边的数作为单独的序列，继续执行上面的操作，当最后序列只有一个元素时，就完成了该序列的排序。

**稳定性：**

> 快速排序并不是稳定的。因为在左右指针放元素的时候，可能会调换相同元素的顺序。

**适用场景：**

> 快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。

**图示：**

![image-20201027200240030](img\image-20201027200240030.png)

![image-20201027200142562](img\image-20201027200142562.png)

代码实现：

```java
public static void quickSort(int[] arrs, int left, int rigth){
    //首先断定如果数组为空，就应该进行方法的返回
    if(arrs == null || arrs.length==0){
        return ;
    }
    //如果left > right 是不合法的，就直接进行返回
    if (left > rigth){
        return;
    }
    //定义变量保存基准数
    int base = arrs[left];
    int l = left;
    int r = rigth;
    while (l != r){
        //先用r来检索 //对于为什么要设置l<r ,如果右边的数全部大于基数的话，
        // 就会让r=-1,造成java.lang.ArrayIndexOutOfBoundsException: -1
        while (arrs[r]>=base && l<r ){
            r--;
        }
        while (arrs[l]<=base && l<r ){
            l++;
        }
        //当停下来的时候，就要进行交换
        int temp = arrs[l];
        arrs[l] = arrs[r];
        arrs[r] = temp;
    }
    //当条件不成立时
    //就要将值放到这里来，将此时的值与left值进行交换
    arrs[left] = arrs[r];
    arrs[r] = base;

    //交换后进行迭代
    //对左边的进行排序
    quickSort(arrs,left,l-1);
    //对右边的进行排序
    quickSort(arrs,l+1,rigth);

}
```

### 5、归并排序（升序）

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用**分治法**的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

**算法描述：**

* 先将一个数列拆分成两个数列，如果拆分的两个数列都是无序的，那就继续进行拆分，直到拆分成单个元素，此时，单个元素就是有序的。
* 对于两个有序的数列，进行头结点的比较，将较小的结点的数字放到新数组中。
* 不断执行第二步，直到只剩下一个数组就结束。

**稳定性:**

> 因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序同样是稳定算法。

**适用场景：**

> 归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。

**图解：**

![image-20201027220514228](img\image-20201027220514228.png)

**代码实现：**

> 这里简单说下关于符号移位的操作： >> 右移符号，<< 左移符号 ，>>> 无符号右移。

```java
//二路分治，需要知道左右，以及中间值
public static void mergeSort(int arrs[],int left,int right){

    //当如果只有一个元素的时候，就不需要进行分治了,退出本次迭代
    if (left == right){
        return;
    }
    //获取分治的中间值,对于除2的操作，我们采用符号移位的操作
    int mid = (left+right)>>>1;

    //然后将左边和右边的分别进行分治操作
    mergeSort(arrs,left,mid);
    mergeSort(arrs,mid+1,right);

    //移位完成后就进行归并操作
    merge(arrs,left,mid,right);

}

private static void merge(int[] arrs, int left, int mid, int right) {
    //由于指针要进行移动，定义指针
    int s1= left;
    int s2 = mid+1;
    //保存临时数组
    int temp[] = new int[right-left+1];
    //临时数组的指针位置
    int i = 0;
    while (s1<=mid && s2<=right){
        //将他们之间比较小的数字晒选出来，放到零时数组中
        if (arrs[s1]<=arrs[s2]){
            //执行后要进行指针的移动
            temp[i++] = arrs[s1++];
        }else{
            temp[i++] = arrs[s2++];
        }
    }
    //当只有一方具有元素的时候，将所有的元素放入到临时数组中
    while (s1<=mid){
        temp[i++] = arrs[s1++];
    }
    while (s2<=right){
        temp[i++] = arrs[s2++];
    }
    //由于只是保存了临时的数组，因此还需要将零时数组中的值拷贝到本地的数组中。
    for (int j = 0; j <temp.length ; j++) {
        arrs[j+left] = temp[j];
    }
}
```

> 讨论复杂度:  时间复杂度:   O(nlogn)   空间复杂度：O(n)    稳定性：是稳定的。

### 6、堆排序（升序）

> 首先明白什么是堆？堆具有两个特点：1、完全二叉树（complete Binary Tree） 2、父节点要大于子节点，然后应该明白什么是完全二叉树，（添加节点的顺序是：从上到下，从左到右）

堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。

对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：（按照下标从0开始算）

- Parent(i) = floor(i-1 /2)，i 的父节点下标
- Left(i) = 2i+1，i 的左子节点下标
- Right(i) = 2i + 2，i 的右子节点下标

**最大堆：**
最大堆中的最大元素值出现在根结点（堆顶）
堆中每个父节点的元素值都大于等于其孩子结点（如果存在）

**最小堆：**
最小堆中的最小元素值出现在根结点（堆顶）
堆中每个父节点的元素值都小于等于其孩子结点（如果存在）

堆排序基本思想：

* 将待排序序列构造成一个大队定

## 二、查找算法

### 1、二分法查找

实现原理：（**实现前提是一组已经排好顺序的数字**）

			* 首先定位首位，末尾，中间位
			* 查看中间位是否等于要查找的数字，等于就退出，否则就判断查找数在中间位的左边还是右边，
			* 左边，将末尾赋值为原中间位，重新计算中间位
			* 右边就将首位定义为中间位，重新计算中间位，
			* 循环下去，直到条件不符合为止。

**利用数组的实现**：

```
public static void main(String[] args) {
    int [] nums = {1,4,8,12,16,52,88,96,105,223};
    //对已经排好序的数字进行二分查找
    System.out.println(QueryNumber(nums,223));

}
public static int QueryNumber(int[] nums, int num){
    int fromNumIndex = 0;
    int toNumIndex = nums.length-1;
    int middleIndex = (fromNumIndex + toNumIndex)/2;
    while(fromNumIndex<=toNumIndex){
        if(num==nums[middleIndex]){
            return middleIndex;
        }else if (nums[middleIndex]<num){
            //也就是在右边的情况下
            fromNumIndex = middleIndex+1;
            middleIndex = (fromNumIndex + toNumIndex)/2;
        }else if(nums[middleIndex]>num){
            //也就是在左边的情况下
            toNumIndex = middleIndex-1;
            middleIndex = (fromNumIndex + toNumIndex)/2;
        }
    }
    //如果没找到就返回-1
    return -1;
}
```