# 分布式以及NOSQL

## 一、互联网时代背景大基于下，为什么要使用nosql

> 随着互联网技术的不断发展，数据量不断的增长，对服务的性能就有了新的要求，各种延伸的技术手段就不断的出现，微服务，分布式等就接着出现。

### 1、单机MySQL下的服务

> 数据量比较小的时候

> 在以前的时候，一个网站一般来说访问量都不是很大，用单个数据库完全可以轻松应付。甚至更多的是静态网页，对于动态交互型的网站搜不是很多。

![image-20201213164858081](img\image-20201213164858081.png)

这里顺便解释下什么是DAO/DAL：

* DAO（Data Access Object）侧重ORM对象关系映射，DAO曾往往提供的是ORM操作。
* DAL（Data Access Layer）多用于分布式系统，分布式系统提供水平伸缩能力，应用层水平扩展后，会使数据库连接资源相对较少成为瓶颈，此时需要对数据库分库、分表，DAL要求支持透明分库分表，DAL层提供的往往是sql

> 但是值得注意的是，这样的设计往往会随着数据的增长等各方面因素出现瓶颈，下面看看都会出现哪些瓶颈问题。

* 数据量的总大小 一个机器放不下时候
* 数据的索引（B + Tree）一个机器存不下时
* 访问量（读写混合）一个实例不能承受时

> 对于上面的根据来说，就是当数据量，访问量达到一定程度时，造成数据访问效率过低，需要一些具体的措施进行解决。

### 2、cache+MySql+垂直拆分

> 随着访问量的上升，数据库的使用上开始出现性能上的问题，因此。需要对数据库的结构进行设计比如说进行**垂直拆分**，以及使用缓存技术来换届数据库的压力，优化数据库的结构和索引，开始使用的是文件作为缓存，但是随着数据量的增大，会造成较高的IO压力，就随之出现了Memcached  redis之类的缓存技术。

> 顺便说下关于垂直拆分与水平拆分：对于垂直拆分，可以说是对业务逻辑进行拆分，解决的问题是当数据库中的某些数据表访问的比较频繁，某些数据库表中的数据访问的频率又比较少，这样，就可以将这些不同模块的表进行垂直拆分，在访问的时候，就对热点数据进行进一步水平拆分以及优化。水平拆分又如何来理解呢？对于一张数据表中，当我们的数据越来越多的时候，在查询的时候，就会造成访问速度的缓慢。比如说1000万条数据情况下，那怎么做呢，就可以将表做水平拆分，将1-300万的数据放到一张表中，300-600万的数据放到一张表中，将600-1000万的数据放到一张表中，并对该表中的数据进行时间维度排序，我们在做查询的时候就非常方便了。并且也提升了效率。

![image-20201217181238712](img\image-20201217181238712.png)

### 3、主从复制+读写分离

> 在上面的模式下，我们对业务进行拆分后，减轻了数据库的压力，但是如果数据继续增加呢？那又该做什么操作呢？就涉及到主从复制和读写分离了，将数据库的写（增删改）和读（查）进行分离，因此又减轻了数据库的压力。当我们在对主数据库写数据时，从数据库能够快速的进行复制。在查数据库时，就仅仅是对从数据库进行读。

![image-20201217183335849](img\image-20201217183335849.png)

### 4、分库分表+水平拆分+集群

> 当我们的数据量达到一个更高的层次，数据的读写频率更高时，现有的技术水平又有了瓶颈，那现在应该如何处理呢？为了缓解写压力和数据扩展的问题，就要进行分库分表的处理了，也就是如mysql cluster集群了，这也是技术上的一个解决方案了。

![image-20201217184849739](img\image-20201217184849739.png)

### 5、NoSql是什么？

> NoSql(Not only sql)  即时不仅仅是SQL,泛指非关系型数据库，随着互联网web2.0网站的兴起，传统的关系型数据库在应对超大规模以及高并发的情况下的纯动态性网站已经显得力不从心了，暴露出了很多的问题，因此，非关系型数据库就得到了飞速的发展，NoSql 数据库的产生就是为了解决大规模数据集合多重数据类型带来的挑战，这些类型的数据存储不需要固定的模式，无需要多余操作就可以横向扩展。 值得说明的是，对于关系型数据库，如果因为业务的需求，需要对业务上进行扩展，不可能一直对一张表进行字段的扩展，这是不现实的，所以更多的就需要这种非关系型数据库。

## 二、NoSql都能干嘛

### 1、易扩展

> NoSql数据库种类繁多，但是一个共同的特点就是去掉关系型数据库的关系特征，数据元之间无关系，这样就非常容易扩展，也在无形之间，在架构的层面上带来了可扩展的能力。

### 2、大数据高性能

> NoSql数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀，这得益于它的无关系性，数据库的结构简单。
>
> 一般的MySql使用Query Cache, 每次表更新Cache就失效，是一种大粒度的Cache,在针对web2.0的交互频繁的应用，Cache性能不高，而NoSql的cache是记录级别的，是一种细粒度的Cache,所以NoSql在这个层面上来说就要性能高很多了。

### 3、多样灵活的数据模型

> NoSql 无需事先为存储的数据建立字段，随时可以村相互自定义的数据格式，而在关系型数据库里，增删改字段是一件非常麻烦的事情，如果是非常大的数据量的表，增加字段简直就是一个噩梦。

### 4、传统RDBMS VS NoSQL

> RDBMS

* 高度组织结构化数据
* 结构化查询语言（SQL）
* 数据和关系都存储在单独的表中
* 数据操纵语言，数据定义语言
* 严格的一致性
* 基础事务

> NoSQL

* 代表的不仅仅是SQL
* 没有声明性查询语言
* 没有预定义的模式
* 键-值对的存储，列存储，文档存储，图形数据库
* 最终一致性，而非ACID属性
* 非结构化和不可预知的数据
* CAP定理
* 高性能，高可用和可伸缩性

### 5、常见的NoSQL实例化

* Redis
* Memcache （专注于高速缓存）
* Mongdb (最像关系型数据库的非关系型，更像是文档类数据库，比如存储一些评论信息啊之类的)

### 6、用来干啥

* KV
* Cache
* Persistence(持久化)

### 7、3V+3高

大数据时代下的3V:

* 海量 Volume （如淘宝的双十一）
* 多样 Variety  （如微博：文字，图片，视频 等多样化）
* 实时 Velocity （如12306票的实时性）

互联网需求的3高：

* 高并发 （如红包，12306，用户数量多）
* 高可扩 （横向扩展：形成集群）
* 高性能

### 8、NoSQL的数据库模型

NoSQL的聚合模型：

* KV键值对  redis
* Bson (类似json) 也可以说是文档数据类型  mongDB
* 列族
* 图论（也就是说有向图和无向图）

## 三、在分布式数据库中的CAP原理和BASE

### 1、传统的ACID分别是什么？

* A (Atomicity) 原子性
* C (Consistency)  一致性
* I  (Isolation)  独立性 （隔离性）
* D (Durability) 持久性

> 关于上面的几个一致性的具体描述就先不做介绍了。

### 2、CAP理论

![20190215093633694](img\20190215093633694.png)

* C (Consistency) 强制一致性 

  > 指的是更新操作成功后并返回客户端时，所有节点在同一时间的数据完全一致，所以说，数据一致性，指的是数据的一致性，分布式就像我们上面说的对数据库做垂直拆分。对于一致性，要从客户端和服务端两个方向来看。从客户端来看，一致性主要指的是多并发访问时更新的数据如何获取的问题，从服务端上来看，就是如何保证主从复制分布到整个系统中。以保证数据的一致性。
  >
  > 对于一致性有三种策略：1、强一致性，对于关系型数据库，要求更新过得数据能被后续访问到。这是强一致性。2、弱一致性，如果能容忍部分或者全部访问不到，则是弱一致性。3、最终一致性，如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。

* A (Availability) 可用性

  > 可用性是指服务一直可用，而且是正常响应时间。对于一个可用性的分布式系统，每一个非故障的节点必须对每个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的（也就是系统不能正常响应），好的可用性能为用户提供更好的体验感，但是影响可用的因素有很多。

* P (Partition tolerance) 分区容错性

  > 分区容错性指的是分布式系统在遇到某节点或网络故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。

> 下面简单说下对于三种理论的  3进2原则： 有的系统仅仅是满足CA,P不存在，也就不存在所谓分布式系统了，如一些数据库 MySql  Oracle等关系型数据库。 有的系统满足于AP, C（强一致性不存在）这是满足用户体验为标准的，比如12306中，你能够形成买票的订单，但是不能做提交，因为已经没有票了，这里就不能满足强一致性，但是达到了最终一致性。而有的系统必须要满足CP,而舍弃了A(可用性)，比如银行的支付系统，就必须要满足资金的强一致性。

推荐博客：[CAP理论的推荐博客](https://blog.csdn.net/wf19930209/article/details/87341874?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160834304316780296850145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160834304316780296850145&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-87341874.nonecase&utm_term=cap理论)

对于其他场景，比较普遍的做法是选择可用性和分区容错性，舍弃强一致性，退而求其次使用最终一致性来保证数据的安全。这其实是分布式领域的另外一个理论——BASE理论。

### 3、BASE 理论

> 如同上面的CAP理论一样，BASE理论也是一个缩写的名词。
>
> 是由Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写。

**解释说明**

强一致性（Strong consistency）无法得到保障时（分区容错和可用性满足系统），我们可以根据业务自身的特点，采用适当的方式来达到最终一致性（Eventual consistency）

从CAP理论我们清楚，对于一个系统来讲，不可能同时满足三者，由于互联网是不可信的，就必须考虑牺牲部分的性能，考虑到用户的体验感，我们就要牺牲部分的强一致性来满足可用性，当然，并不是说就不能达到一致性，这是不正确的，而是要让系统达到最终一致性。下面就这三个名词做一定的说明：

* Basically Available(基本可用)

  > 基本可用是相对于正常的系统来说的,常见如下情况
  >
  > - 响应时间上的损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用看的搜索结果可能要1秒，2秒甚至3秒（超过3秒用户就接受不了了）
  > - 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了促销时间，可能为了应对并发，保护购物系统的稳定性，部分用户会被引导到一个降级页面

* Soft state（软状态）

  > 软状态是相对原子性来说的
  >
  > - 原子性（硬状态） -> 要求多个节点的数据副本都是一致的,这是一种"硬状态"
  > - 软状态（弱状态） -> 允许系统中的数据存在中间状态,并认为该状态不影响系统的整体可用性,即允许系统在多个不同节点的数据副本存在数据延迟

* Eventually consistent（最终一致性）

  > **弱一致性** 
  > 和强一致性相对 
  > 系统并不保证连续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后， **不承诺立即可以读到最新写入的值**，也不会具体的承诺多久之后可以读到。但会 **尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态**。
  >
  > **最终一致性是弱一致性的特定形式**
  >
  > 对于软状态,我们允许中间状态存在，但不可能一直是中间状态，必须要有个期限，系统保证在没有后续更新的前提下,在这个期限后,系统最终返回上一次更新操作的值,从而达到数据的最终一致性,这个容忍期限（不一致窗口的时间）取决于通信延迟，系统负载，数据复制方案设计，复制副本个数等，DNS是一个典型的最终一致性系统。
  >
  > 最终一致性模型变种
  >
  > - 因果一致性（Causal consistency）
  >
  > 如果节点A在更新完某个数据后通知了节点B,那么节点B的访问修改操作都是基于A更新后的值,同时,和节点A没有因果关系的C的数据访问则没有这样的限制
  >
  > - 读己之所写（Read your writes）
  >
  > 因果一致性的特定形式，一个节点A总可以读到自己更新的数据
  >
  > - 会话一致性（Session consistency）
  >
  > 访问存储系统同一个有效的会话，系统应保证该进程读己之所写
  >
  > - 单调读一致性（Monotonic read consistency）
  >
  > 一个节点从系统中读取一个特定值之后，那么该节点从系统中不会读取到该值以前的任何值
  >
  > - 单调写一致性（Monotonic write consistency）
  >
  > 一个系统要能够保证来自同一个节点的写操作被顺序执行（保证写操作串行化）
  >
  > 实践中，往往5个系统进行排列组合，当然，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例

### 4、分布式与集群

> 后面我们将会接触到分布式系统的使用，因此，这里简单介绍下什么是分布式和集群
>
> 分布式：也就是不同的机器上提供不同的服务
>
> 集群：就是不同的机器上提供相同的服务